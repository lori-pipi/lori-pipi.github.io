<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="Lori3rrrr">
    
    <title>
        
            c++InterviewPreparation |
        
        Loriperb
    </title>
    <link rel="stylesheet" href="/css/style.css">
    <link rel="shortcut icon" href="/images/logo.svg">
    <link rel="stylesheet" href="/css/font-awesome.min.css">
    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"example.com","root":"/","language":"en"};
    KEEP.theme_config = {"toc":{"enable":false,"number":false,"expand_all":false,"init_open":false},"style":{"primary_color":"#B0C4DE","avatar":"/images/avatar.svg","favicon":"/images/logo.svg","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":false,"scale":false},"first_screen":{"enable":true,"background_img":"/images/bg.svg","description":"yes,we can!"},"scroll":{"progress_bar":{"enable":false},"percent":{"enable":false}}},"local_search":{"enable":false,"preload":false},"code_copy":{"enable":false,"style":"default"},"pjax":{"enable":false},"lazyload":{"enable":false},"version":"3.4.0"};
    KEEP.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days age","week":"%s weeks age","month":"%s months age","year":"%s years age"};
  </script>
<meta name="generator" content="Hexo 5.3.0"></head>


<body>
<div class="progress-bar-container">
    

    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            <a class="logo-title" href="/">
                Loriperb
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                HOME
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                ARCHIVES
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >
                                CATEGORIES
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/about"
                            >
                                ABOUT
                            </a>
                        </li>
                    
                    
                </ul>
            </div>
            <div class="mobile">
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">HOME</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">ARCHIVES</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories">CATEGORIES</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/about">ABOUT</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">c++InterviewPreparation</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/avatar.svg">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">Lori3rrrr</span>
                        
                            <span class="author-label">Lv3</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;2021-04-22 14:58:25
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/categories/tech/">tech</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    

    
    
    
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <h3 id="Bytedance提纲"><a href="#Bytedance提纲" class="headerlink" title="Bytedance提纲"></a>Bytedance提纲</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-C++语言特性</span><br><span class="line">-计算机网络</span><br><span class="line">-数据结构和算法</span><br><span class="line">-数据库</span><br><span class="line">-操作系统</span><br><span class="line">-网络编程</span><br><span class="line">-项目</span><br></pre></td></tr></table></figure>
<h4 id="C-语言特性"><a href="#C-语言特性" class="headerlink" title="C++语言特性"></a>C++语言特性</h4><h5 id="1-面向对象的三大特性"><a href="#1-面向对象的三大特性" class="headerlink" title="1.面向对象的三大特性"></a>1.面向对象的三大特性</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">封装</span><br><span class="line">继承</span><br><span class="line">多态</span><br></pre></td></tr></table></figure>
<h5 id="2-类的访问权限：private、protected、public"><a href="#2-类的访问权限：private、protected、public" class="headerlink" title="2.类的访问权限：private、protected、public"></a>2.类的访问权限：private、protected、public</h5><p>基于对本类，子类，外部类的访问控制权限。</p>
<p>在c++中继承方式也分为这三种，仅仅影响派生类的访问控制权限。</p>
<h5 id="3-类的构造函数、析构函数、赋值函数、拷贝函数"><a href="#3-类的构造函数、析构函数、赋值函数、拷贝函数" class="headerlink" title="3.类的构造函数、析构函数、赋值函数、拷贝函数"></a>3.类的构造函数、析构函数、赋值函数、拷贝函数</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">构造函数：MyClass() :i(0) &#123; &#125; MyClass(int n) : i(n) &#123; &#125;</span><br><span class="line">析构函数：对象消亡时，自动被调用，用来释放对象占用的空间。    ~Test()</span><br><span class="line">赋值函数： A &amp; operate &#x3D;( const A &amp;other); &#x2F;&#x2F; 赋值函数</span><br><span class="line">拷贝函数： A(const A &amp;other); &#x2F;&#x2F; 拷贝构造函数</span><br><span class="line">拷贝构造函数是在对象被创建时调用的，而赋值函数只能被已经存在了的对象调用。</span><br></pre></td></tr></table></figure>
<h5 id="4-左值引用和右值引用"><a href="#4-左值引用和右值引用" class="headerlink" title="4.左值引用和右值引用"></a>4.左值引用和右值引用</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">左值是可以放在赋值号左边可以被赋值的值；左值必须要在内存中有实体；</span><br><span class="line">右值当在赋值号右边取出值赋给其他变量的值；右值可以在内存也可以在CPU寄存器。</span><br><span class="line">一个对象被用作右值时，使用的是它的内容(值)，被当作左值时，使用的是它的地址。</span><br></pre></td></tr></table></figure>
<h5 id="5-浅拷贝和深拷贝"><a href="#5-浅拷贝和深拷贝" class="headerlink" title="5.浅拷贝和深拷贝"></a>5.浅拷贝和深拷贝</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">c++primer里面有一章讲到了这个，讲的很清楚。</span><br><span class="line">是针对指针的，浅拷贝是只拷贝指针地址，意思是浅拷贝指针都指向同一个内存空间，当原指针地址所指空间被释放，那么浅拷贝的指针全部失效。</span><br><span class="line">深拷贝是先申请一块跟被拷贝数据一样大的内存空间，把数据复制过去。这样拷贝多少次，就有多少个不同的内存空间，干扰不到对方。</span><br><span class="line">怎么用这个浅拷贝或深拷贝要看具体条件，我以前一直觉得深拷贝就是好，但是c++primer上的例子让我觉得看情况。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="6-空类的默认成员和大小"><a href="#6-空类的默认成员和大小" class="headerlink" title="6.空类的默认成员和大小"></a>6.空类的默认成员和大小</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果你只是声明一个空类，不做任何事情的话，编译器会自动为你生成一个默认构造函数、一个拷贝默认构造函数、一个默认拷贝赋值操作符、一个默认析构函数、取址运算符和一个取址运算符const。这些函数只有在第一次被调用时，才会别编译器创建。所有这些函数都是inline和public的。</span><br><span class="line">在C++中空类会占一个字节，这是为了让对象的实例能够相互区别。具体来说，空类同样可以被实例化，并且每个实例在内存中都有独一无二的地址。</span><br></pre></td></tr></table></figure>
<h5 id="7-内存分区：全局区、堆区、栈区、常量区、代码区"><a href="#7-内存分区：全局区、堆区、栈区、常量区、代码区" class="headerlink" title="7.内存分区：全局区、堆区、栈区、常量区、代码区"></a>7.内存分区：全局区、堆区、栈区、常量区、代码区</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">一个C&#x2F;C++编译的程序占用的内存分为以下几个部分</span><br><span class="line">1、栈区（stack）： 由编译器自动分配释放，存放函数的参数值、局部变量的值等，其操作方式类似于数据结构中的栈</span><br><span class="line">2、堆区（heap）：一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收，注意它与数据结构中的堆是两回事，分配方式倒是类似于链表</span><br><span class="line">3、全局区（静态区 static）： 全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化静态变量在相邻的另一块区域，程序结束后由系统释放。</span><br><span class="line">4、文字常量区：常量字符串就是存放在该区，程序结束后由系统释放</span><br><span class="line">5、程序代码区：存放函数体的二进制代码</span><br></pre></td></tr></table></figure>
<h5 id="8-struct与class的区别"><a href="#8-struct与class的区别" class="headerlink" title="8.struct与class的区别"></a>8.struct与class的区别</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">从语法上，在C++中（只讨论C++中）。class和struct做类型定义时只有两点区别：</span><br><span class="line">（一）默认继承权限。如果不明确指定，来自class的继承按照private继承处理，来自struct的继承按照public继承处理。</span><br><span class="line">（二）成员的默认访问权限。class的成员默认是private权限，struct默认是public权限。</span><br><span class="line">除了这两点，class和struct基本就是一个东西。语法上没有任何其它区别。</span><br></pre></td></tr></table></figure>
<h5 id="9-class-struct内存对齐"><a href="#9-class-struct内存对齐" class="headerlink" title="9.class,struct内存对齐"></a>9.class,struct内存对齐</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sizeof(结构体)＝整数×最宽的成员</span><br></pre></td></tr></table></figure>
<h5 id="10-new-delete与malloc-free的区别"><a href="#10-new-delete与malloc-free的区别" class="headerlink" title="10.new/delete与malloc/free的区别"></a>10.new/delete与malloc/free的区别</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">malloc与free是C++&#x2F;C 语言的标准库函数，new&#x2F;delete 是C++的运算符。</span><br><span class="line">对象在创建的同时要自动执行构造函数， 对象消亡之前要自动执行析构函数。由于malloc&#x2F;free 是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加malloc&#x2F;free。</span><br><span class="line">int *p1 &#x3D; (int *)malloc(sizeof(int) * length);</span><br><span class="line">int *p2 &#x3D; new int[length];&#x2F;&#x2F;usage</span><br><span class="line">new 内置了sizeof、类型转换和类型安全检查功能。</span><br><span class="line">int* p &#x3D; new float[2]; &#x2F;&#x2F; 编译时指出错误</span><br><span class="line">int* p &#x3D; malloc(2*sizeof(float)); &#x2F;&#x2F; 编译时无法指出错误</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">new 、delete 是操作符，可以重载，只能在C++ 中使用。</span><br><span class="line">malloc、free 是函数，可以覆盖，C、C++ 中都可以使用。</span><br><span class="line">new 可以调用对象的构造函数，对应的delete 调用相应的析构函数。</span><br><span class="line">malloc 仅仅分配内存，free 仅仅回收内存，并不执行构造和析构函数</span><br><span class="line">new 、delete 返回的是某种数据类型指针，malloc、free 返回的是void 指针。</span><br><span class="line">「注意」：malloc 申请的内存空间要用free 释放，而new 申请的内存空间要用delete 释放，不要混用。</span><br></pre></td></tr></table></figure>
<h5 id="11-c-内存泄露的情况"><a href="#11-c-内存泄露的情况" class="headerlink" title="11.c++内存泄露的情况"></a>11.c++内存泄露的情况</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">在编写应用程序的时候，程序分配了一块内存，但已经不再持有引用这块内存的对象（通常是指针），虽然这些内存被分配出去，但是无法收回，将无法被其他的进程所使用，我们说这块内存泄漏了，被泄漏的内存将在整个程序声明周期内都不可使用。</span><br><span class="line">1.malloc free未配对出现（即new和delete未配对出现）。</span><br><span class="line">2.局部函数内分配未回收。</span><br><span class="line">3.回收地址错误new delete用法问题。</span><br><span class="line">4.程序运行过程中出现的不可预见的错误，导致了内存泄漏。</span><br><span class="line">5.没有将基类的析构函数定义为虚函数，当基类的指针指向子类时，delete该对象时，不会调用子类的析构函数</span><br></pre></td></tr></table></figure>
<h5 id="12-指针和引用的区别"><a href="#12-指针和引用的区别" class="headerlink" title="12.指针和引用的区别"></a>12.指针和引用的区别</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">从概念上讲。指针从本质上讲就是存放变量地址的一个变量，在逻辑上是独立的，它可以被改变，包括其所指向的地址的改变和其指向的地址中所存放的数据的改变。</span><br><span class="line">而引用是一个别名，它在逻辑上不是独立的，它的存在具有依附性，所以引用必须在一开始就被初始化，而且其引用的对象在其整个生命周期中是不能被改变的（自始至终只能依附于同一个变量）。</span><br></pre></td></tr></table></figure>
<h5 id="13-野指针的出现和针对办法"><a href="#13-野指针的出现和针对办法" class="headerlink" title="13.野指针的出现和针对办法"></a>13.野指针的出现和针对办法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在删除一个指针之后，一定将该指针设置成空指针（即在delete *p之后一定要加上： p&#x3D;NULL）</span><br></pre></td></tr></table></figure>
<h5 id="14-动态绑定和静态绑定"><a href="#14-动态绑定和静态绑定" class="headerlink" title="14.动态绑定和静态绑定"></a>14.动态绑定和静态绑定</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">静态类型：对象声明时的类型，编译时确定</span><br><span class="line">动态类型：目前所指对象的类型，运行时确定</span><br><span class="line">静态多态：也称为编译期间的多态，编译器在编译期间完成的，编译器根据函数实参的类型(可能会进行隐式类型转换)，可推断出要调用那个函数，如果有对应的函数就调用该函数，否则出现编译错误。</span><br><span class="line">静态多态有两种实现方式：</span><br><span class="line">函数重载：包括普通函数的重载和成员函数的重载</span><br><span class="line">函数模板的使用</span><br><span class="line">动态多态（动态绑定）：即运行时的多态，在程序执行期间(非编译期)判断所引用对象的实际类型，根据其实际类型调用相应的方法。</span><br><span class="line">注意区分重载 重写 重定义。</span><br></pre></td></tr></table></figure>
<h5 id="15-虚函数实现动态多态的原理、虚函数与纯虚函数的区别"><a href="#15-虚函数实现动态多态的原理、虚函数与纯虚函数的区别" class="headerlink" title="15.虚函数实现动态多态的原理、虚函数与纯虚函数的区别"></a>15.虚函数实现动态多态的原理、虚函数与纯虚函数的区别</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">虚函数+virtual</span><br><span class="line">纯虚函数在基类中定义后+virtual+&#x3D;0</span><br><span class="line">纯虚函数在基类中不定义，专门等待子类重写。包含纯虚函数的类叫做抽象类。</span><br><span class="line">动态多态通过虚函数表来实现。</span><br><span class="line">在基类和子类都会维护各自的虚函数表，</span><br><span class="line">子类的虚函数表包括子类独有的虚函数和从基类继承得到的虚函数，此时，如果子类重写了</span><br><span class="line">基类的虚函数就会在子类的虚函数表内覆盖掉原有的基类的虚函数。</span><br></pre></td></tr></table></figure>
<h5 id="16-static关键字"><a href="#16-static关键字" class="headerlink" title="16.static关键字"></a>16.static关键字</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">只要是static修饰的变量，包括全局变量，局部变量，类成员变量，类成员函数都存储在全局数据区。</span><br><span class="line">作用域最多仅限在本类或本文件不受extern的影响。</span><br><span class="line">声明后就会被初始化为0。</span><br><span class="line">与之相反的是extern关键字，其可以多次声明一个变量，让编译器去外部文件搜索这个变量的具体定义。</span><br></pre></td></tr></table></figure>
<h5 id="17-const关键字"><a href="#17-const关键字" class="headerlink" title="17.const关键字"></a>17.const关键字</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">修饰常对象：被修饰的对象只能访问const修饰的成员变量或者函数</span><br><span class="line">const Student stu1</span><br><span class="line">修饰成员函数：被修饰的成员函数可以访问所有的成员变量，但是只能读取不能修改</span><br><span class="line">void getName() const</span><br><span class="line">修饰成员变量：被修饰的成员变量只能通过构造函数的初始化列表初始化，之后不能修改。</span><br><span class="line">const string name</span><br><span class="line">修饰指针：</span><br><span class="line">（1）const int *p1;</span><br><span class="line">（2）int const *p2;</span><br><span class="line">（3）int * const p3;</span><br><span class="line">（4）const int * const p4;</span><br><span class="line">（5）int const * const p5;</span><br><span class="line">1）和（2）相同，表示此指针指向的变量是只读的，指针的值可以修改，但指向的数据不能修改，相当于(const int ) * p;</span><br><span class="line">（3）表示指针本身的值不能修改，此指针是一个常量</span><br><span class="line">（4）（5）标示指针本身的值和所指向的值都不能被修改。</span><br><span class="line">注意：在此一定要注意const的意思，const只是不允许程序中的代码改变某一变量，其在编译期发挥作用，它并没有实际地禁止某段内存的读写特性。</span><br></pre></td></tr></table></figure>
<h5 id="18-volatile关键字"><a href="#18-volatile关键字" class="headerlink" title="18.volatile关键字"></a>18.volatile关键字</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">对特殊变量的稳定访问（比如寄存器变量或者端口数据）</span><br><span class="line">实现方式就是每一次都从对应的内存地址读。</span><br><span class="line">------------------------------------------------------</span><br><span class="line">PS：可以用const和volatile同时修饰变量，表示这个变量在程序内部是只读的，不能改变的，只在程序外部条件变化下改变，并且编译器不会优化这个变量。每次使用这个变量时，都要小心地去内存读取这个变量的值，而不是去寄存器读取它的备份。</span><br></pre></td></tr></table></figure>
<h5 id="19-C-的显式类型转换的关键字"><a href="#19-C-的显式类型转换的关键字" class="headerlink" title="19.C++的显式类型转换的关键字"></a>19.C++的显式类型转换的关键字</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.static_cast 只用于良性转换低风险，原有的自动类型转换如short 转 int、int 转 double</span><br><span class="line">2.const_cast 它用来去掉表达式的 const 修饰或 volatile 修饰。换句话说，const_cast 就是用来将 const&#x2F;volatile 类型转换为非 const&#x2F;volatile 类型。</span><br><span class="line">3.reinterpret_cast可以认为是 static_cast 的一种补充，一些 static_cast 不能完成的转换，就可以用 reinterpret_cast 来完成，例如两个具体类型指针之间的转换、int 和指针之间的转换</span><br><span class="line">4.dynamic_cast用于在类的继承层次之间进行类型转换，它既允许向上转型（Upcasting），也允许向下转型（Downcasting）。向上转型是无条件的，不会进行任何检测，所以都能成功；向下转型的前提必须是安全的，要借助 RTTI 进行检测，所有只有一部分能成功。</span><br></pre></td></tr></table></figure>
<h5 id="20-右值引用和std：：move"><a href="#20-右值引用和std：：move" class="headerlink" title="20.右值引用和std：：move"></a>20.右值引用和std：：move</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">右值虽然无法获取地址，但是右值引用是可以获取地址的，该地址表示临时对象的存储位置。</span><br><span class="line">move 它并不是重新分配一块新的空间，将要拷贝的对象复制过来，而是&quot;偷&quot;了过来，将自己的指针指向别人的资源，然后将别人的指针修改为nullptr，这一步很重要，如果不将别人的指针修改为空，那么临时对象析构的时候就会释放掉这个资源，&quot;偷&quot;也白偷了。</span><br></pre></td></tr></table></figure>
<h5 id="21-智能指针"><a href="#21-智能指针" class="headerlink" title="21.智能指针"></a>21.智能指针</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">智能指针是存储指向动态分配（堆）对象指针的类。除了能够在适当的时间自动删除指向的对象外，他们的工作机制很像C++的内置指针。智能指针在面对异常的时候格外有用，因为他们能够确保正确的销毁动态分配的对象。他们也可以用于跟踪被多用户共享的动态分配对象。</span><br><span class="line">shared_poiter:当引用计数减少到0的时候就释放引用的对象。这种引用计数的增减发生在智能指针的构造函数，复制构造函数，赋值操作符，析构函数中。</span><br><span class="line">这种方式使得多个智能指针同时对所引用的对象有拥有权，同时在引用计数减到0之后也会自动释放内存，也实现了auto_ptr和unique_ptr的资源释放的功能。</span><br><span class="line">weak_poiter:弱引用，用来避免循环引用出现的情况，并手动释放内存。</span><br></pre></td></tr></table></figure>
<h5 id="22-重载-重写-重定义"><a href="#22-重载-重写-重定义" class="headerlink" title="22.重载 重写 重定义"></a>22.重载 重写 重定义</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Overload(重载)：在C++程序中，可以将语义、功能相似的几个函数用同一个名字表示，但参数或返回值不同（包括类型、顺序不同），即函数重载。</span><br><span class="line">（1）相同的范围（在同一个类中）；</span><br><span class="line">（2）函数名字相同；</span><br><span class="line">（3）参数不同；</span><br><span class="line">（4）virtual 关键字可有可无。</span><br><span class="line">Override(重写)：是指派生类函数覆盖基类函数，特征是：</span><br><span class="line">（1）不同的范围（分别位于派生类与基类）；</span><br><span class="line">（2）函数名字相同；</span><br><span class="line">（3）参数相同；</span><br><span class="line">（4）基类函数必须有virtual 关键字。</span><br><span class="line">&#x2F;&#x2F;实现多态的手段</span><br><span class="line">Overwrite(重定义)：是指派生类的函数屏蔽了与其同名的基类函数，规则如下：</span><br><span class="line">（1）如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual</span><br><span class="line">关键字，基类的函数将被隐藏（注意别与重载混淆）。</span><br><span class="line">（2）如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual</span><br><span class="line">关键字。此时，基类的函数被隐藏（注意别与覆盖混淆）。</span><br></pre></td></tr></table></figure>
<h5 id="23-全局变量和局部变量有什么区别？实怎么实现的？操作系统和编译器是怎么知道的？"><a href="#23-全局变量和局部变量有什么区别？实怎么实现的？操作系统和编译器是怎么知道的？" class="headerlink" title="23.全局变量和局部变量有什么区别？实怎么实现的？操作系统和编译器是怎么知道的？"></a>23.<strong>全局变量和局部变量有什么区别？实怎么实现的？操作系统和编译器是怎么知道的？</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">全局变量是整个程序都可访问的变量，谁都可以访问，生存期在整个程序从运行到结束（在程序结束时所占内存释放）；</span><br><span class="line">而局部变量存在于模块（子程序，函数）中，只有所在模块可以访问，其他模块不可直接访问，模块结束（函数调用完毕），局部变量消失，所占据的内存释放。</span><br><span class="line">操作系统和编译器，可能是通过内存分配的位置来知道的，全局变量分配在全局数据段并且在程序开始运行的时候被加载.局部变量则分配在堆栈里面</span><br></pre></td></tr></table></figure>
<h5 id="24-动态库和静态库"><a href="#24-动态库和静态库" class="headerlink" title="24.动态库和静态库"></a>24.动态库和静态库</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">库是共享程序代码的方式，一般分为静态库和动态库。</span><br><span class="line">静态库：链接时完整地拷贝至可执行文件中，被多次使用就有多份冗余拷贝。</span><br><span class="line">动态库：链接时不复制，程序运行时由系统动态加载到内存，供程序调用，系统只加载一次，多个程序共用，节省内存。</span><br></pre></td></tr></table></figure>
<h5 id="25lambda表达式的基本用法"><a href="#25lambda表达式的基本用法" class="headerlink" title="25lambda表达式的基本用法"></a>25lambda表达式的基本用法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Lambda表达式完整的声明格式如下：</span><br><span class="line"></span><br><span class="line">[capture list] (params list) mutable exception-&gt; return type &#123; function body &#125;</span><br><span class="line">各项具体含义如下</span><br><span class="line"></span><br><span class="line">capture list：捕获外部变量列表</span><br><span class="line">params list：形参列表</span><br><span class="line">mutable指示符：用来说用是否可以修改捕获的变量</span><br><span class="line">exception：异常设定</span><br><span class="line">return type：返回类型</span><br><span class="line">function body：函数体</span><br><span class="line">常用格式：[capture list] (params list) &#123;function body&#125;(assignment for params list)</span><br><span class="line">[capture list] &#123;function body&#125;(...)</span><br></pre></td></tr></table></figure>
<p>eg:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a &#x3D; 123;</span><br><span class="line">    auto f &#x3D; [a] &#123; cout &lt;&lt; a &lt;&lt; endl; &#125;; </span><br><span class="line">    f(); &#x2F;&#x2F; 输出：123</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;或通过“函数体”后面的‘()’传入参数</span><br><span class="line">    auto x &#x3D; [](int a)&#123;cout &lt;&lt; a &lt;&lt; endl;&#125;(123); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="26"><a href="#26" class="headerlink" title="26."></a>26.</h5>
        </div>

        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/2021/04/22/OperatingSystem/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">OSInterviewPreparation</span>
                                <span class="post-nav-item">Prev posts</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/2021/04/22/AlgorithmofBinaryTree&amp;&amp;ListProblems/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">Algorithm of BinaryTree&amp;&amp;List</span>
                                <span class="post-nav-item">Next posts</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2020</span>&nbsp;-&nbsp;
            
            2023&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">Lori3rrrr</a>
        </div>
        
        <div class="theme-info info-item">
            Powered by <a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;|&nbsp;Theme&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.0</a>
        </div>
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="fas fa-arrow-up"></i>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    

    <div class="image-viewer-container">
    <img src="">
</div>


    

</main>



<script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/header-shrink.js"></script><script src="/js/back2top.js"></script><script src="/js/dark-light-toggle.js"></script>







<div class="post-scripts">
    
</div>



</body>
</html>
