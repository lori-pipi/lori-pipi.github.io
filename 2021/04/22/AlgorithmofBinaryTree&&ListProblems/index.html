<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="Lori3rrrr">
    
    <title>
        
            Algorithm of BinaryTree&amp;&amp;List |
        
        Loriperb
    </title>
    <link rel="stylesheet" href="/css/style.css">
    <link rel="shortcut icon" href="/images/logo.svg">
    <link rel="stylesheet" href="/css/font-awesome.min.css">
    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"example.com","root":"/","language":"en"};
    KEEP.theme_config = {"toc":{"enable":false,"number":false,"expand_all":false,"init_open":false},"style":{"primary_color":"#B0C4DE","avatar":"/images/avatar.svg","favicon":"/images/logo.svg","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":false,"scale":false},"first_screen":{"enable":true,"background_img":"/images/bg.svg","description":"yes,we can!"},"scroll":{"progress_bar":{"enable":false},"percent":{"enable":false}}},"local_search":{"enable":false,"preload":false},"code_copy":{"enable":false,"style":"default"},"pjax":{"enable":false},"lazyload":{"enable":false},"version":"3.4.0"};
    KEEP.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days age","week":"%s weeks age","month":"%s months age","year":"%s years age"};
  </script>
<meta name="generator" content="Hexo 5.3.0"></head>


<body>
<div class="progress-bar-container">
    

    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            <a class="logo-title" href="/">
                Loriperb
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                HOME
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                ARCHIVES
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >
                                CATEGORIES
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/about"
                            >
                                ABOUT
                            </a>
                        </li>
                    
                    
                </ul>
            </div>
            <div class="mobile">
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">HOME</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">ARCHIVES</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories">CATEGORIES</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/about">ABOUT</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">Algorithm of BinaryTree&amp;&amp;List</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/avatar.svg">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">Lori3rrrr</span>
                        
                            <span class="author-label">Lv3</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;2021-04-22 11:58:25
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/categories/algorithm/">algorithm</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    

    
    
    
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <h3 id="剑指Offer刷题经验集"><a href="#剑指Offer刷题经验集" class="headerlink" title="剑指Offer刷题经验集"></a>剑指Offer刷题经验集</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-专栏</span><br><span class="line">-二叉树</span><br><span class="line">-链表</span><br></pre></td></tr></table></figure>
<h4 id="Get-Start"><a href="#Get-Start" class="headerlink" title="Get Start"></a>Get Start</h4><h5 id="1-Offer06从尾到头打印链表"><a href="#1-Offer06从尾到头打印链表" class="headerlink" title="1.Offer06从尾到头打印链表"></a>1.Offer06从尾到头打印链表</h5><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p>
<p>示例 1：输入：head = [1,3,2]<br>                       输出：[2,3,1]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">reversePrint</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">    <span class="keyword">if</span>(head-&gt;next==<span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;head-&gt;val&#125;;</span><br><span class="line">    ListNode* pre=<span class="literal">nullptr</span>;</span><br><span class="line">    ListNode* cur=head;</span><br><span class="line">    ListNode* post=head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(post!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">      cur-&gt;next=pre;</span><br><span class="line">      pre=cur;</span><br><span class="line">      cur=post;</span><br><span class="line">      post=post-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    cur-&gt;next=pre;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">while</span>(cur!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        ans.push_back(cur-&gt;val);</span><br><span class="line">        cur=cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//本题我采用的思路是三指针反转链表，再从链表尾一次遍历反转后的链表实现从尾到头顺序的打印。</span></span><br><span class="line"><span class="comment">//当然本题也可以采用栈的数据结构。</span></span><br><span class="line"><span class="comment">//通过这个题我主要练习的应该是反转链表这个高频考点！</span></span><br></pre></td></tr></table></figure>


<h5 id="2-Offer07重建二叉树"><a href="#2-Offer07重建二叉树" class="headerlink" title="2.Offer07重建二叉树"></a>2.Offer07重建二叉树</h5><p>输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p>
<p>Eg:</p>
<p>前序遍历 preorder = [3,9,20,15,7]<br>       中序遍历 inorder = [9,3,15,20,7]<br>返回如下的二叉树：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如，给出</span><br><span class="line">前序遍历 preorder &#x3D; [3,9,20,15,7]</span><br><span class="line">中序遍历 inorder &#x3D; [9,3,15,20,7]</span><br><span class="line">返回如下的二叉树：</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;mp;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorder;</span><br><span class="line">	<span class="function">TreeNode* <span class="title">constructTree</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (l &gt; r)<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">		TreeNode* node = <span class="keyword">new</span> TreeNode(preorder[root]);</span><br><span class="line">		<span class="keyword">int</span> index_in_inorder = mp[preorder[root]];</span><br><span class="line">		node-&gt;left = constructTree(root + <span class="number">1</span>,  l, index_in_inorder - <span class="number">1</span>);</span><br><span class="line">		node-&gt;right = constructTree(root + index_in_inorder - l + <span class="number">1</span>, index_in_inorder + <span class="number">1</span>, r);</span><br><span class="line">		<span class="keyword">return</span> node;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;preorder=preorder;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inorder.size(); i++) &#123;</span><br><span class="line">			mp[inorder[i]] = i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> constructTree(<span class="number">0</span>, <span class="number">0</span>, inorder.size() - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//通过递归调用左右子树的方式建树</span></span><br><span class="line"><span class="comment">//核心在于每一次通过寻找到中序遍历的根节点的位置确定左右子树的长度，再通过左右子树的长度和先序遍历的序列确定下一个左右子树的各自的根节点的位置。</span></span><br><span class="line"><span class="comment">//递归构造的结束条件非常类似大多数的递归，通过左边界大于右边界的方式来终止。</span></span><br><span class="line"><span class="comment">//因为本道题目不含有重复的数字，每一个数字可以看作是一个唯一且独特的节点，我们需要知道每一次遍历过程中的根节点在先序序列和中序序列中各自的位置，可以通过该节点的val值建立map表来查询处理。</span></span><br></pre></td></tr></table></figure>


<h5 id="3-Offer18删除链表中的节点"><a href="#3-Offer18删除链表中的节点" class="headerlink" title="3.Offer18删除链表中的节点"></a>3.Offer18删除链表中的节点</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteNode</span><span class="params">(ListNode* head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    ListNode* yummyhead=<span class="keyword">new</span> ListNode();</span><br><span class="line">    yummyhead-&gt;next=head;</span><br><span class="line">    <span class="keyword">if</span>(head-&gt;val==val)<span class="keyword">return</span> head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(head-&gt;next!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(head-&gt;next-&gt;val==val)&#123;</span><br><span class="line">            head-&gt;next=head-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> head=head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> yummyhead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//哑节点（即指向头节点之前一个位置的节点），主要作用是方便代码适应头节点这样的特殊位置上的节点。</span></span><br></pre></td></tr></table></figure>
<h5 id="4-Offer22返回链表中倒数第k个节点"><a href="#4-Offer22返回链表中倒数第k个节点" class="headerlink" title="4.Offer22返回链表中倒数第k个节点"></a>4.Offer22返回链表中倒数第k个节点</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">ListNode* <span class="title">getKthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">		ListNode* front = head;</span><br><span class="line">		ListNode* before = head;</span><br><span class="line">		<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (front-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">			front = front-&gt;next;</span><br><span class="line">			i++;</span><br><span class="line">			<span class="keyword">if</span> (i &gt;= k) &#123;</span><br><span class="line">				before = before-&gt;next;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> before;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//双指针</span></span><br></pre></td></tr></table></figure>
<h5 id="5-Offer26树的子结构"><a href="#5-Offer26树的子结构" class="headerlink" title="5.Offer26树的子结构"></a>5.Offer26树的子结构</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</span><br><span class="line"></span><br><span class="line">B是A的子结构， 即 A中有出现和B相同的结构和节点值。</span><br><span class="line"></span><br><span class="line">例如:</span><br><span class="line">给定的树 A:</span><br><span class="line"></span><br><span class="line">     3</span><br><span class="line">    &#x2F; \</span><br><span class="line">   4   5</span><br><span class="line">  &#x2F; \</span><br><span class="line"> 1   2</span><br><span class="line">给定的树 B：</span><br><span class="line"></span><br><span class="line">   4 </span><br><span class="line">  &#x2F;</span><br><span class="line"> 1</span><br><span class="line">返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：A &#x3D; [1,2,3], B &#x3D; [3,1]</span><br><span class="line">输出：false</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：A &#x3D; [3,4,5,1,2], B &#x3D; [4,1]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	TreeNode* ans;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">findtar</span><span class="params">(TreeNode* root, TreeNode* tar)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (root == <span class="literal">nullptr</span>)<span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">if</span> (root-&gt;val == tar-&gt;val)ans = root;</span><br><span class="line">		<span class="comment">// cout &lt;&lt; root-&gt;val &lt;&lt; endl;</span></span><br><span class="line">		findtar(root-&gt;left, tar);</span><br><span class="line">		findtar(root-&gt;right, tar);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">isSimilar</span><span class="params">(TreeNode* a, TreeNode* b)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (a == <span class="literal">nullptr</span>&amp;&amp;b != <span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (a != <span class="literal">nullptr</span>&amp;&amp;b == <span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="literal">nullptr</span>&amp;&amp;b == <span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (a-&gt;val == b-&gt;val) <span class="keyword">return</span> isSimilar(a-&gt;left, b-&gt;left) &amp;&amp; isSimilar(a-&gt;right, b-&gt;right);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">isSubStructure</span><span class="params">(TreeNode* A, TreeNode* B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(B==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		findtar(A, B);</span><br><span class="line">		<span class="keyword">if</span> (ans == <span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">return</span> isSimilar(ans, B);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//递归思想判别相同树</span></span><br><span class="line"><span class="comment">//先寻找和B的root节点值相同的在A中的节点x，然后判断x的子树中是否含有和B的结构相同的部分。</span></span><br></pre></td></tr></table></figure>
<h5 id="6-Offer27二叉树的镜像"><a href="#6-Offer27二叉树的镜像" class="headerlink" title="6.Offer27二叉树的镜像"></a>6.Offer27二叉树的镜像</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">请完成一个函数，输入一个二叉树，该函数输出它的镜像。</span><br><span class="line"></span><br><span class="line">例如输入：</span><br><span class="line"></span><br><span class="line">     4</span><br><span class="line">   &#x2F;   \</span><br><span class="line">  2     7</span><br><span class="line"> &#x2F; \   &#x2F; \</span><br><span class="line">1   3 6   9</span><br><span class="line">镜像输出：</span><br><span class="line"></span><br><span class="line">     4</span><br><span class="line">   &#x2F;   \</span><br><span class="line">  7     2</span><br><span class="line"> &#x2F; \   &#x2F; \</span><br><span class="line">9   6 3   1</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：root &#x3D; [4,2,7,1,3,6,9]</span><br><span class="line">输出：[4,7,2,9,6,3,1]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">domirror</span><span class="params">(TreeNode* t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t==<span class="literal">nullptr</span>)<span class="keyword">return</span>;</span><br><span class="line">     TreeNode* tmp=t-&gt;left;</span><br><span class="line">     t-&gt;left=t-&gt;right;</span><br><span class="line">     t-&gt;right=tmp;</span><br><span class="line">     domirror(t-&gt;left);</span><br><span class="line">     domirror(t-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mirrorTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">     domirror(root);</span><br><span class="line">     <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//二叉树的问题经常用到递归</span></span><br><span class="line"><span class="comment">//递归还是所有方法中我个人认为最具有挑战性的一类</span></span><br><span class="line"><span class="comment">//尽管本题很普通，还是想放上来多呈现一些递归使用的例子</span></span><br></pre></td></tr></table></figure>
<h5 id="7-Offer28对称的二叉树"><a href="#7-Offer28对称的二叉树" class="headerlink" title="7.Offer28对称的二叉树"></a>7.Offer28对称的二叉树</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</span><br><span class="line"></span><br><span class="line">例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</span><br><span class="line"></span><br><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   2</span><br><span class="line"> &#x2F; \ &#x2F; \</span><br><span class="line">3  4 4  3</span><br><span class="line">但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</span><br><span class="line"></span><br><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   2</span><br><span class="line">   \   \</span><br><span class="line">   3    3</span><br><span class="line">示例 1：</span><br><span class="line">输入：root &#x3D; [1,2,2,3,4,4,3]</span><br><span class="line">输出：true</span><br><span class="line">示例 2：</span><br><span class="line">输入：root &#x3D; [1,2,2,null,3,null,3]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">buildMirrorTree</span><span class="params">(TreeNode* t)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (t == <span class="literal">nullptr</span>)<span class="keyword">return</span>;</span><br><span class="line">		TreeNode* tmp = t-&gt;left;</span><br><span class="line">		t-&gt;left = t-&gt;right;</span><br><span class="line">		t-&gt;right = tmp;</span><br><span class="line">		buildMirrorTree(t-&gt;left);</span><br><span class="line">		buildMirrorTree(t-&gt;right);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">isSimilar</span><span class="params">(TreeNode* a, TreeNode* b)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (a == <span class="literal">nullptr</span>&amp;&amp;b == <span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">if</span> (a == <span class="literal">nullptr</span>&amp;&amp;b != <span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">if</span> (a != <span class="literal">nullptr</span>&amp;&amp;b == <span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">if</span> (a-&gt;val == b-&gt;val)<span class="keyword">return</span> isSimilar(a-&gt;left, b-&gt;left) &amp;&amp; isSimilar(a-&gt;right, b-&gt;right);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">prePrintTree</span><span class="params">(TreeNode* t)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (t == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;null&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; t-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		prePrintTree(t-&gt;left);</span><br><span class="line">		prePrintTree(t-&gt;right);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">bfsPrintTree</span><span class="params">(TreeNode* t)</span> </span>&#123;</span><br><span class="line">		<span class="built_in">queue</span>&lt;TreeNode*&gt;s;</span><br><span class="line">		s.push(t);</span><br><span class="line">		<span class="keyword">while</span> (!s.empty()) &#123;</span><br><span class="line">			TreeNode* tmp = s.front();</span><br><span class="line">			s.pop();</span><br><span class="line">			<span class="keyword">if</span> (tmp == <span class="literal">nullptr</span>)<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;null&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; tmp-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">				s.push(tmp-&gt;left);</span><br><span class="line">				s.push(tmp-&gt;right);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">TreeNode* <span class="title">TreeClone</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (root == <span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">		TreeNode* new_root = <span class="keyword">new</span> TreeNode(root-&gt;val);</span><br><span class="line">		new_root-&gt;left = TreeClone(root-&gt;left);</span><br><span class="line">		new_root-&gt;right = TreeClone(root-&gt;right);</span><br><span class="line">		<span class="keyword">return</span> new_root;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">		TreeNode* mirror_root = TreeClone(root);</span><br><span class="line">		buildMirrorTree(mirror_root);</span><br><span class="line">		<span class="keyword">return</span> isSimilar(root, mirror_root);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//本体代码量大主要原因是我写了一些和解决该问题无关的函数</span></span><br><span class="line"><span class="comment">//这些函数包括先序打印二叉树，深拷贝一个二叉树，层序遍历二叉树等，都是比较实用的测试结果的工具。</span></span><br></pre></td></tr></table></figure>
<h5 id="8-Offer32-1-从上到下打印二叉树"><a href="#8-Offer32-1-从上到下打印二叉树" class="headerlink" title="8.Offer32-1 从上到下打印二叉树"></a>8.Offer32-1 从上到下打印二叉树</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</span><br><span class="line">例如:</span><br><span class="line">给定二叉树: [3,9,20,null,null,15,7],</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line"></span><br><span class="line">返回：</span><br><span class="line">[3,9,20,15,7]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bfsPrintTree</span><span class="params">(TreeNode* t)</span> </span>&#123;</span><br><span class="line">		<span class="built_in">queue</span>&lt;TreeNode*&gt;s;</span><br><span class="line">		s.push(t);</span><br><span class="line">		<span class="keyword">while</span> (!s.empty()) &#123;</span><br><span class="line">			TreeNode* tmp = s.front();</span><br><span class="line">			s.pop();</span><br><span class="line">			<span class="keyword">if</span>(tmp!=<span class="literal">nullptr</span>) &#123;</span><br><span class="line">			    ans.push_back(tmp-&gt;val);</span><br><span class="line">				s.push(tmp-&gt;left);</span><br><span class="line">				s.push(tmp-&gt;right);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">       bfsPrintTree(root);</span><br><span class="line">       <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//迭代 队列 BFS</span></span><br></pre></td></tr></table></figure>
<h5 id="9-Offer-32-2从上到下打印二叉树"><a href="#9-Offer-32-2从上到下打印二叉树" class="headerlink" title="9.Offer-32-2从上到下打印二叉树"></a>9.Offer-32-2从上到下打印二叉树</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</span><br><span class="line">例如:</span><br><span class="line">给定二叉树: [<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,null,null,<span class="number">15</span>,<span class="number">7</span>],</span><br><span class="line"></span><br><span class="line">    <span class="number">3</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">9</span>  <span class="number">20</span></span><br><span class="line">    /  \</span><br><span class="line">   <span class="number">15</span>   <span class="number">7</span></span><br><span class="line"></span><br><span class="line">返回其层次遍历结果：</span><br><span class="line">[</span><br><span class="line">  [<span class="number">3</span>],</span><br><span class="line">  [<span class="number">9</span>,<span class="number">20</span>],</span><br><span class="line">  [<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bfsPrintTree</span><span class="params">(TreeNode* t)</span> </span>&#123;</span><br><span class="line">		<span class="built_in">queue</span>&lt;TreeNode*&gt;s;</span><br><span class="line">		s.push(t);</span><br><span class="line">        <span class="keyword">int</span> layer=<span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">		<span class="keyword">while</span> (!s.empty()) &#123;</span><br><span class="line">            ans.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">            <span class="keyword">int</span> count=s.size();</span><br><span class="line">            <span class="keyword">while</span>(count)&#123;</span><br><span class="line">			TreeNode* tmp = s.front();</span><br><span class="line">			s.pop();</span><br><span class="line">			<span class="keyword">if</span>(tmp!=<span class="literal">nullptr</span>) &#123;</span><br><span class="line">			ans[layer].push_back(tmp-&gt;val);</span><br><span class="line">				s.push(tmp-&gt;left);</span><br><span class="line">				s.push(tmp-&gt;right);</span><br><span class="line">			&#125;</span><br><span class="line">            count--;</span><br><span class="line">		&#125;</span><br><span class="line">        layer++;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">     bfsPrintTree(root);</span><br><span class="line">     ans.erase(ans.end()<span class="number">-1</span>);</span><br><span class="line">     <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//关注队列层次遍历常用的count方法！</span></span><br></pre></td></tr></table></figure>
<h5 id="10-Offer-32-3从上到下打印二叉树"><a href="#10-Offer-32-3从上到下打印二叉树" class="headerlink" title="10.Offer-32-3从上到下打印二叉树"></a>10.Offer-32-3从上到下打印二叉树</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</span><br><span class="line">例如:</span><br><span class="line">给定二叉树: [3,9,20,null,null,15,7],</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line">返回其层次遍历结果：</span><br><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [20,9],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bfsPrintTree</span><span class="params">(TreeNode* t)</span> </span>&#123;</span><br><span class="line">		<span class="built_in">queue</span>&lt;TreeNode*&gt;s;</span><br><span class="line">		s.push(t);</span><br><span class="line">        <span class="keyword">int</span> layer=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!s.empty()) &#123;</span><br><span class="line">            ans.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">            <span class="keyword">int</span> count=s.size();</span><br><span class="line">            <span class="keyword">while</span>(count)&#123;</span><br><span class="line">			TreeNode* tmp = s.front();</span><br><span class="line">			s.pop();</span><br><span class="line">			<span class="keyword">if</span>(tmp!=<span class="literal">nullptr</span>) &#123;</span><br><span class="line">			ans[layer].push_back(tmp-&gt;val);</span><br><span class="line">				s.push(tmp-&gt;left);</span><br><span class="line">				s.push(tmp-&gt;right);</span><br><span class="line">			&#125;</span><br><span class="line">            count--;</span><br><span class="line">		&#125;</span><br><span class="line">        layer++;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">     bfsPrintTree(root);</span><br><span class="line">     ans.erase(ans.end()<span class="number">-1</span>);</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ans.size();i++)&#123;</span><br><span class="line">         <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">             reverse(ans[i].begin(),ans[i].end());</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//reverse函数的使用</span></span><br></pre></td></tr></table></figure>
<h5 id="11-Offer33二叉搜索树的后序遍历序列"><a href="#11-Offer33二叉搜索树的后序遍历序列" class="headerlink" title="11.Offer33二叉搜索树的后序遍历序列"></a>11.Offer33二叉搜索树的后序遍历序列</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。</span><br><span class="line">参考以下这颗二叉搜索树：</span><br><span class="line"></span><br><span class="line">     5</span><br><span class="line">    &#x2F; \</span><br><span class="line">   2   6</span><br><span class="line">  &#x2F; \</span><br><span class="line"> 1   3</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入: [1,6,3,2,5]</span><br><span class="line">输出: false</span><br><span class="line">示例 2：</span><br><span class="line">输入: [1,3,2,6,5]</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">recur</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; v,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(l&gt;=r)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">int</span> l_begin=l,l_end=l;</span><br><span class="line">  <span class="keyword">int</span> r_begin,r_end;</span><br><span class="line">  <span class="keyword">int</span> root=v[r];</span><br><span class="line">  <span class="keyword">while</span>(v[l_end]&lt;root)&#123;</span><br><span class="line">      l_end++;</span><br><span class="line">  &#125;</span><br><span class="line">  r_begin=l_end;</span><br><span class="line">  r_end=r_begin;</span><br><span class="line">  l_end-=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(v[r_end]&gt;root)&#123;</span><br><span class="line">      r_end++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> r_end==r&amp;&amp;recur(v,l_begin,l_end)&amp;&amp;recur(v,r_begin,r_end<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">verifyPostorder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> recur(postorder,<span class="number">0</span>,postorder.size()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">    <span class="comment">//the key of solving this problem is to find that the root can  always divide the tree into 2 subtrees, and we can use that cahracter to make recurrsion solution</span></span><br></pre></td></tr></table></figure>
<h5 id="12-Offer34二叉树中和为某一值的路径"><a href="#12-Offer34二叉树中和为某一值的路径" class="headerlink" title="12.Offer34二叉树中和为某一值的路径"></a>12.Offer34二叉树中和为某一值的路径</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。</span><br><span class="line">示例:</span><br><span class="line">给定如下二叉树，以及目标和 target &#x3D; 22，</span><br><span class="line"></span><br><span class="line">              5</span><br><span class="line">             &#x2F; \</span><br><span class="line">            4   8</span><br><span class="line">           &#x2F;   &#x2F; \</span><br><span class="line">          11  13  4</span><br><span class="line">         &#x2F;  \    &#x2F; \</span><br><span class="line">        7    2  5   1</span><br><span class="line">返回:</span><br><span class="line">[</span><br><span class="line">   [5,4,11,2],</span><br><span class="line">   [5,8,4,5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">	<span class="keyword">int</span> tar;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">recur</span><span class="params">(TreeNode* cur)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">			path.push_back(cur-&gt;val);</span><br><span class="line">			tar -= cur-&gt;val;</span><br><span class="line">			<span class="keyword">if</span> (tar != <span class="number">0</span> || cur-&gt;left != <span class="literal">nullptr</span> || cur-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">				recur(cur-&gt;left);</span><br><span class="line">				recur(cur-&gt;right);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				ans.push_back(path);</span><br><span class="line">			&#125;</span><br><span class="line">			path.pop_back();</span><br><span class="line">			tar += cur-&gt;val;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; pathSum(TreeNode* root, <span class="keyword">int</span> target) &#123;</span><br><span class="line">		tar = target;</span><br><span class="line">		recur(root);</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//how to implement backtracking method in code</span></span><br></pre></td></tr></table></figure>
<h5 id="13-Offer35复杂链表的复制"><a href="#13-Offer35复杂链表的复制" class="headerlink" title="13.Offer35复杂链表的复制"></a>13.Offer35复杂链表的复制</h5><h5 id="14-Offer36二叉搜索树和双向链表"><a href="#14-Offer36二叉搜索树和双向链表" class="headerlink" title="14.Offer36二叉搜索树和双向链表"></a>14.Offer36二叉搜索树和双向链表</h5><h5 id="15-Offer37序列化二叉树"><a href="#15-Offer37序列化二叉树" class="headerlink" title="15.Offer37序列化二叉树"></a>15.Offer37序列化二叉树</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">请实现两个函数，分别用来序列化和反序列化二叉树。</span><br><span class="line">示例: </span><br><span class="line">你可以将以下二叉树：</span><br><span class="line"></span><br><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   3</span><br><span class="line">     &#x2F; \</span><br><span class="line">    4   5</span><br><span class="line"></span><br><span class="line">序列化为 &quot;[1,2,3,null,null,4,5]&quot;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Codec</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">	<span class="function"><span class="built_in">string</span> <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">		<span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">		<span class="built_in">queue</span>&lt;TreeNode*&gt; record;</span><br><span class="line">		q.push(root);</span><br><span class="line">		<span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">			TreeNode* tmp = q.front();</span><br><span class="line">			q.pop();</span><br><span class="line">			record.push(tmp);</span><br><span class="line">			<span class="keyword">if</span> (tmp ==<span class="literal">nullptr</span>)<span class="keyword">continue</span>;</span><br><span class="line">			q.push(tmp-&gt;left);</span><br><span class="line">			q.push(tmp-&gt;right);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">string</span> res;</span><br><span class="line">		<span class="keyword">while</span> (!record.empty()) &#123;</span><br><span class="line">			TreeNode* tmp = record.front();</span><br><span class="line">		<span class="keyword">if</span> (tmp == <span class="literal">nullptr</span>)res = res.append(<span class="string">&quot;null &quot;</span>);</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				res = res.append(to_string(tmp-&gt;val)+<span class="string">&quot; &quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			record.pop();</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//    cout&lt;&lt;res&lt;&lt;endl;</span></span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">	<span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(<span class="built_in">string</span> data)</span> </span>&#123;</span><br><span class="line">		<span class="function"><span class="built_in">stringstream</span> <span class="title">input</span><span class="params">(data)</span></span>;</span><br><span class="line">		<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">		<span class="built_in">string</span> tmp;</span><br><span class="line">		<span class="keyword">while</span> (input &gt;&gt; tmp) &#123;</span><br><span class="line">			res.push_back(tmp);</span><br><span class="line">		&#125;</span><br><span class="line">        	<span class="comment">// cout &lt;&lt; res.size()&lt;&lt;endl;</span></span><br><span class="line">		<span class="built_in">queue</span>&lt;TreeNode*&gt;q;</span><br><span class="line">		<span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> cal = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (res[<span class="number">0</span>] == <span class="string">&quot;null&quot;</span>)<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">		TreeNode* ans = <span class="keyword">new</span> TreeNode(stoi(res[<span class="number">0</span>]));</span><br><span class="line">		q.push(ans);</span><br><span class="line">		<span class="keyword">while</span> (i &lt; res.size()&amp;&amp;!q.empty()) &#123;</span><br><span class="line">			<span class="keyword">if</span> (res[i] != <span class="string">&quot;null&quot;</span>) &#123;</span><br><span class="line">				TreeNode* t = <span class="keyword">new</span> TreeNode(stoi(res[i]));</span><br><span class="line">				q.push(t);</span><br><span class="line">				<span class="keyword">if</span> (cal % <span class="number">2</span> == <span class="number">0</span>)q.front()-&gt;left = t;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					q.front()-&gt;right = t;</span><br><span class="line">					q.pop();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (cal % <span class="number">2</span> == <span class="number">0</span>)q.front()-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					q.front()-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">					q.pop();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			cal++;</span><br><span class="line">            i++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//这道题感觉就没什么学的，主要是了解了一下stringtream分割空格符字符串，int转string，string转int，</span></span><br><span class="line"><span class="comment">//以及很重要的是string中用+连接字符串比用append函数慢很多很多！！！</span></span><br><span class="line"><span class="comment">// Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Codec codec;</span></span><br><span class="line"><span class="comment">// codec.deserialize(codec.serialize(root));</span></span><br></pre></td></tr></table></figure>
<h5 id="16-Offer54二叉搜索树的第k大个节点"><a href="#16-Offer54二叉搜索树的第k大个节点" class="headerlink" title="16.Offer54二叉搜索树的第k大个节点"></a>16.Offer54二叉搜索树的第k大个节点</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">给定一棵二叉搜索树，请找出其中第k大的节点。</span><br><span class="line">示例 1:</span><br><span class="line">输入: root &#x3D; [3,1,4,null,2], k &#x3D; 1</span><br><span class="line">   3</span><br><span class="line">  &#x2F; \</span><br><span class="line"> 1   4</span><br><span class="line">  \</span><br><span class="line">   2</span><br><span class="line">输出: 4</span><br><span class="line">示例 2:</span><br><span class="line">输入: root &#x3D; [5,3,6,2,4,null,null,1], k &#x3D; 3</span><br><span class="line">       5</span><br><span class="line">      &#x2F; \</span><br><span class="line">     3   6</span><br><span class="line">    &#x2F; \</span><br><span class="line">   2   4</span><br><span class="line">  &#x2F;</span><br><span class="line"> 1</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">     <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">int</span> ans=<span class="number">0</span>; </span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode*cur)</span></span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(cur==<span class="literal">nullptr</span>)<span class="keyword">return</span>;</span><br><span class="line">         dfs(cur-&gt;left);</span><br><span class="line">         count--;</span><br><span class="line">         <span class="keyword">if</span>(count==<span class="number">0</span>)ans=cur-&gt;val;</span><br><span class="line">         dfs(cur-&gt;right);</span><br><span class="line">     &#125;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">dfs_nodes</span><span class="params">(TreeNode*cur)</span></span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(cur==<span class="literal">nullptr</span>)<span class="keyword">return</span>;</span><br><span class="line">         dfs_nodes(cur-&gt;left);</span><br><span class="line">         count++;</span><br><span class="line">         dfs_nodes(cur-&gt;right);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthLargest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">          dfs_nodes(root);</span><br><span class="line">          count=count-k+<span class="number">1</span>;</span><br><span class="line">          dfs(root);</span><br><span class="line">          <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//本题有趣的地方在于查找第k[大]个节点</span></span><br><span class="line"><span class="comment">//我们常常受到中序遍历的思维定势，觉得只能通过递归的代码去找第k小的节点</span></span><br><span class="line"><span class="comment">//如果转变通常的思路把形如下方的代码改变为</span></span><br><span class="line"><span class="comment">// dfs_nodes(cur-&gt;left);</span></span><br><span class="line"><span class="comment">//       count++;</span></span><br><span class="line"><span class="comment">//dfs_nodes(cur-&gt;right);</span></span><br><span class="line"><span class="comment">//change to:</span></span><br><span class="line"><span class="comment">// dfs_nodes(cur-&gt;right);</span></span><br><span class="line"><span class="comment">//       count++;</span></span><br><span class="line"><span class="comment">//dfs_nodes(cur-&gt;left);</span></span><br><span class="line"><span class="comment">//不就迎刃而解了吗？</span></span><br><span class="line"><span class="comment">//我使用的仍然是普通中序遍历的思路</span></span><br><span class="line"><span class="comment">//因此需要先遍历整棵二叉树查找总共有多少个节点</span></span><br><span class="line"><span class="comment">//在通过普通的中序遍历找第size-k个节点。</span></span><br></pre></td></tr></table></figure>
<h5 id="17-Offer55-1二叉树的深度"><a href="#17-Offer55-1二叉树的深度" class="headerlink" title="17.Offer55-1二叉树的深度"></a>17.Offer55-1二叉树的深度</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。</span><br><span class="line">例如：</span><br><span class="line">给定二叉树 [3,9,20,null,null,15,7]，</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line">返回它的最大深度 3 。</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* cur,<span class="keyword">int</span> layer)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur==<span class="literal">nullptr</span>)<span class="keyword">return</span>;</span><br><span class="line">          ans=max(layer,ans);</span><br><span class="line">        dfs(cur-&gt;left,layer+<span class="number">1</span>);</span><br><span class="line">        dfs(cur-&gt;right,layer+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">          dfs(root,<span class="number">1</span>);</span><br><span class="line">          <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//双while+count=q.size();q--;写bfs层序遍历别忘了！</span></span><br></pre></td></tr></table></figure>
<h5 id="18-Offer55-2平衡二叉树"><a href="#18-Offer55-2平衡二叉树" class="headerlink" title="18.Offer55-2平衡二叉树"></a>18.Offer55-2平衡二叉树</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过<span class="number">1</span>，那么它就是一棵平衡二叉树。</span><br><span class="line">示例 <span class="number">1</span>:</span><br><span class="line">给定二叉树 [<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,null,null,<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line"></span><br><span class="line">    <span class="number">3</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">9</span>  <span class="number">20</span></span><br><span class="line">    /  \</span><br><span class="line">   <span class="number">15</span>   <span class="number">7</span></span><br><span class="line">返回 <span class="literal">true</span> 。</span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line">给定二叉树 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,null,null,<span class="number">4</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">       <span class="number">1</span></span><br><span class="line">      / \</span><br><span class="line">     <span class="number">2</span>   <span class="number">2</span></span><br><span class="line">    / \</span><br><span class="line">   <span class="number">3</span>   <span class="number">3</span></span><br><span class="line">  / \</span><br><span class="line"> <span class="number">4</span>   <span class="number">4</span></span><br><span class="line">返回 <span class="literal">false</span> 。</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">bool</span> ans=<span class="literal">true</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">depth_dfs</span><span class="params">(TreeNode*cur)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur==<span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> depthL=depth_dfs(cur-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> depthR=depth_dfs(cur-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(depthL-depthR)&gt;<span class="number">1</span>)ans=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> max(depthL,depthR)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">         depth_dfs(root);</span><br><span class="line">         <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//递归</span></span><br></pre></td></tr></table></figure>
<h5 id="19-Offer68-1二叉搜索树的最近公共祖先"><a href="#19-Offer68-1二叉搜索树的最近公共祖先" class="headerlink" title="19.Offer68-1二叉搜索树的最近公共祖先"></a>19.Offer68-1二叉搜索树的最近公共祖先</h5><p><img src="/images/binarytree.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</span><br><span class="line">百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</span><br><span class="line">例如，给定如下二叉搜索树:  root &#x3D; [6,2,8,0,4,7,9,null,null,3,5]</span><br><span class="line">示例 1:</span><br><span class="line">输入: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 8</span><br><span class="line">输出: 6 </span><br><span class="line">解释: 节点 2 和节点 8 的最近公共祖先是 6。</span><br><span class="line">示例 2:</span><br><span class="line">输入: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 4</span><br><span class="line">输出: 2</span><br><span class="line">解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        TreeNode* ans=root;</span><br><span class="line">        <span class="keyword">while</span>(ans!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>((ans-&gt;val-p-&gt;val)*(ans-&gt;val-q-&gt;val)&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ans-&gt;val-p-&gt;val&gt;<span class="number">0</span>)ans=ans-&gt;left;</span><br><span class="line">            <span class="keyword">else</span> ans=ans-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//这道题目迭代的方法非常简单和容易理解，学习这样的思路！</span></span><br></pre></td></tr></table></figure>
<h5 id="20-Offer68-2二叉树的最近公共祖先"><a href="#20-Offer68-2二叉树的最近公共祖先" class="headerlink" title="20.Offer68-2二叉树的最近公共祖先"></a>20.Offer68-2二叉树的最近公共祖先</h5><p><img src="/images/binarytree2.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</span><br><span class="line">百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</span><br><span class="line">例如，给定如下二叉树:  root &#x3D; [3,5,1,6,2,0,8,null,null,7,4]</span><br><span class="line">示例 1:</span><br><span class="line">输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1</span><br><span class="line">输出: 3</span><br><span class="line">解释: 节点 5 和节点 1 的最近公共祖先是节点 3。</span><br><span class="line">示例 2:</span><br><span class="line">输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 4</span><br><span class="line">输出: 5</span><br><span class="line">解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode* ans;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(TreeNode* root,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">bool</span> lson=dfs(root-&gt;left,l,r);</span><br><span class="line">        <span class="keyword">bool</span> rson=dfs(root-&gt;right,l,r);</span><br><span class="line">        <span class="keyword">if</span>(lson&amp;&amp;rson||((lson||rson)&amp;&amp;(root-&gt;val==l||root-&gt;val==r)))ans=root;</span><br><span class="line">        <span class="keyword">return</span> lson||rson||root-&gt;val==l||root-&gt;val==r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l=p-&gt;val;</span><br><span class="line">        <span class="keyword">int</span> r=q-&gt;val;</span><br><span class="line">        <span class="keyword">bool</span> s=dfs(root,l,r);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//这个递归就用的很牛逼了，需要仔细学习思考一下！</span></span><br><span class="line"><span class="comment">//运用到了递归时自底向上的性质</span></span><br></pre></td></tr></table></figure>

        </div>

        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/2021/04/22/C++/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">c++InterviewPreparation</span>
                                <span class="post-nav-item">Prev posts</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/2021/04/02/ComputerNetworkNote/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">Computer Network Note</span>
                                <span class="post-nav-item">Next posts</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2020</span>&nbsp;-&nbsp;
            
            2023&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">Lori3rrrr</a>
        </div>
        
        <div class="theme-info info-item">
            Powered by <a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;|&nbsp;Theme&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.0</a>
        </div>
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="fas fa-arrow-up"></i>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    

    <div class="image-viewer-container">
    <img src="">
</div>


    

</main>



<script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/header-shrink.js"></script><script src="/js/back2top.js"></script><script src="/js/dark-light-toggle.js"></script>







<div class="post-scripts">
    
</div>



</body>
</html>
