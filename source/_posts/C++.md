---

title: c++InterviewPreparation
date: 2021-04-22 14:58:25
updated: 2020-04-22 14:58:25
categories: [tech]
---

### Bytedance提纲

```
-C++语言特性
-计算机网络
-数据结构和算法
-数据库
-操作系统
-网络编程
-项目
```

#### C++语言特性

##### 1.面向对象的三大特性

```
封装
继承
多态
```

##### 2.类的访问权限：private、protected、public

基于对本类，子类，外部类的访问控制权限。

在c++中继承方式也分为这三种，仅仅影响派生类的访问控制权限。

##### 3.类的构造函数、析构函数、赋值函数、拷贝函数

```
构造函数：MyClass() :i(0) { } MyClass(int n) : i(n) { }
析构函数：对象消亡时，自动被调用，用来释放对象占用的空间。    ~Test()
赋值函数： A & operate =( const A &other); // 赋值函数
拷贝函数： A(const A &other); // 拷贝构造函数
拷贝构造函数是在对象被创建时调用的，而赋值函数只能被已经存在了的对象调用。
```

##### 4.左值引用和右值引用

```
左值是可以放在赋值号左边可以被赋值的值；左值必须要在内存中有实体；
右值当在赋值号右边取出值赋给其他变量的值；右值可以在内存也可以在CPU寄存器。
一个对象被用作右值时，使用的是它的内容(值)，被当作左值时，使用的是它的地址。
```

##### 5.浅拷贝和深拷贝

```
c++primer里面有一章讲到了这个，讲的很清楚。
是针对指针的，浅拷贝是只拷贝指针地址，意思是浅拷贝指针都指向同一个内存空间，当原指针地址所指空间被释放，那么浅拷贝的指针全部失效。
深拷贝是先申请一块跟被拷贝数据一样大的内存空间，把数据复制过去。这样拷贝多少次，就有多少个不同的内存空间，干扰不到对方。
怎么用这个浅拷贝或深拷贝要看具体条件，我以前一直觉得深拷贝就是好，但是c++primer上的例子让我觉得看情况。

```

##### 6.空类的默认成员和大小

```
如果你只是声明一个空类，不做任何事情的话，编译器会自动为你生成一个默认构造函数、一个拷贝默认构造函数、一个默认拷贝赋值操作符、一个默认析构函数、取址运算符和一个取址运算符const。这些函数只有在第一次被调用时，才会别编译器创建。所有这些函数都是inline和public的。
在C++中空类会占一个字节，这是为了让对象的实例能够相互区别。具体来说，空类同样可以被实例化，并且每个实例在内存中都有独一无二的地址。
```

##### 7.内存分区：全局区、堆区、栈区、常量区、代码区

```
一个C/C++编译的程序占用的内存分为以下几个部分
1、栈区（stack）： 由编译器自动分配释放，存放函数的参数值、局部变量的值等，其操作方式类似于数据结构中的栈
2、堆区（heap）：一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收，注意它与数据结构中的堆是两回事，分配方式倒是类似于链表
3、全局区（静态区 static）： 全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化静态变量在相邻的另一块区域，程序结束后由系统释放。
4、文字常量区：常量字符串就是存放在该区，程序结束后由系统释放
5、程序代码区：存放函数体的二进制代码
```

##### 8.struct与class的区别

```
从语法上，在C++中（只讨论C++中）。class和struct做类型定义时只有两点区别：
（一）默认继承权限。如果不明确指定，来自class的继承按照private继承处理，来自struct的继承按照public继承处理。
（二）成员的默认访问权限。class的成员默认是private权限，struct默认是public权限。
除了这两点，class和struct基本就是一个东西。语法上没有任何其它区别。
```

##### 9.class,struct内存对齐

```
sizeof(结构体)＝整数×最宽的成员
```

##### 10.new/delete与malloc/free的区别

```
malloc与free是C++/C 语言的标准库函数，new/delete 是C++的运算符。
对象在创建的同时要自动执行构造函数， 对象消亡之前要自动执行析构函数。由于malloc/free 是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加malloc/free。
int *p1 = (int *)malloc(sizeof(int) * length);
int *p2 = new int[length];//usage
new 内置了sizeof、类型转换和类型安全检查功能。
int* p = new float[2]; // 编译时指出错误
int* p = malloc(2*sizeof(float)); // 编译时无法指出错误
----------------------------------------------------------------------
new 、delete 是操作符，可以重载，只能在C++ 中使用。
malloc、free 是函数，可以覆盖，C、C++ 中都可以使用。
new 可以调用对象的构造函数，对应的delete 调用相应的析构函数。
malloc 仅仅分配内存，free 仅仅回收内存，并不执行构造和析构函数
new 、delete 返回的是某种数据类型指针，malloc、free 返回的是void 指针。
「注意」：malloc 申请的内存空间要用free 释放，而new 申请的内存空间要用delete 释放，不要混用。
```

##### 11.c++内存泄露的情况

```
在编写应用程序的时候，程序分配了一块内存，但已经不再持有引用这块内存的对象（通常是指针），虽然这些内存被分配出去，但是无法收回，将无法被其他的进程所使用，我们说这块内存泄漏了，被泄漏的内存将在整个程序声明周期内都不可使用。
1.malloc free未配对出现（即new和delete未配对出现）。
2.局部函数内分配未回收。
3.回收地址错误new delete用法问题。
4.程序运行过程中出现的不可预见的错误，导致了内存泄漏。
5.没有将基类的析构函数定义为虚函数，当基类的指针指向子类时，delete该对象时，不会调用子类的析构函数
```

##### 12.指针和引用的区别

```
从概念上讲。指针从本质上讲就是存放变量地址的一个变量，在逻辑上是独立的，它可以被改变，包括其所指向的地址的改变和其指向的地址中所存放的数据的改变。
而引用是一个别名，它在逻辑上不是独立的，它的存在具有依附性，所以引用必须在一开始就被初始化，而且其引用的对象在其整个生命周期中是不能被改变的（自始至终只能依附于同一个变量）。
```

##### 13.野指针的出现和针对办法

```
在删除一个指针之后，一定将该指针设置成空指针（即在delete *p之后一定要加上： p=NULL）
```

##### 14.动态绑定和静态绑定

```
静态类型：对象声明时的类型，编译时确定
动态类型：目前所指对象的类型，运行时确定
静态多态：也称为编译期间的多态，编译器在编译期间完成的，编译器根据函数实参的类型(可能会进行隐式类型转换)，可推断出要调用那个函数，如果有对应的函数就调用该函数，否则出现编译错误。
静态多态有两种实现方式：
函数重载：包括普通函数的重载和成员函数的重载
函数模板的使用
动态多态（动态绑定）：即运行时的多态，在程序执行期间(非编译期)判断所引用对象的实际类型，根据其实际类型调用相应的方法。
注意区分重载 重写 重定义。
```

##### 15.虚函数实现动态多态的原理、虚函数与纯虚函数的区别

```
虚函数+virtual
纯虚函数在基类中定义后+virtual+=0
纯虚函数在基类中不定义，专门等待子类重写。包含纯虚函数的类叫做抽象类。
动态多态通过虚函数表来实现。
在基类和子类都会维护各自的虚函数表，
子类的虚函数表包括子类独有的虚函数和从基类继承得到的虚函数，此时，如果子类重写了
基类的虚函数就会在子类的虚函数表内覆盖掉原有的基类的虚函数。
```

##### 16.static关键字

```
只要是static修饰的变量，包括全局变量，局部变量，类成员变量，类成员函数都存储在全局数据区。
作用域最多仅限在本类或本文件不受extern的影响。
声明后就会被初始化为0。
与之相反的是extern关键字，其可以多次声明一个变量，让编译器去外部文件搜索这个变量的具体定义。
```

##### 17.const关键字

```
修饰常对象：被修饰的对象只能访问const修饰的成员变量或者函数
const Student stu1
修饰成员函数：被修饰的成员函数可以访问所有的成员变量，但是只能读取不能修改
void getName() const
修饰成员变量：被修饰的成员变量只能通过构造函数的初始化列表初始化，之后不能修改。
const string name
修饰指针：
（1）const int *p1;
（2）int const *p2;
（3）int * const p3;
（4）const int * const p4;
（5）int const * const p5;
1）和（2）相同，表示此指针指向的变量是只读的，指针的值可以修改，但指向的数据不能修改，相当于(const int ) * p;
（3）表示指针本身的值不能修改，此指针是一个常量
（4）（5）标示指针本身的值和所指向的值都不能被修改。
注意：在此一定要注意const的意思，const只是不允许程序中的代码改变某一变量，其在编译期发挥作用，它并没有实际地禁止某段内存的读写特性。
```

##### 18.volatile关键字

```
对特殊变量的稳定访问（比如寄存器变量或者端口数据）
实现方式就是每一次都从对应的内存地址读。
------------------------------------------------------
PS：可以用const和volatile同时修饰变量，表示这个变量在程序内部是只读的，不能改变的，只在程序外部条件变化下改变，并且编译器不会优化这个变量。每次使用这个变量时，都要小心地去内存读取这个变量的值，而不是去寄存器读取它的备份。
```

##### 19.C++的显式类型转换的关键字

```
1.static_cast 只用于良性转换低风险，原有的自动类型转换如short 转 int、int 转 double
2.const_cast 它用来去掉表达式的 const 修饰或 volatile 修饰。换句话说，const_cast 就是用来将 const/volatile 类型转换为非 const/volatile 类型。
3.reinterpret_cast可以认为是 static_cast 的一种补充，一些 static_cast 不能完成的转换，就可以用 reinterpret_cast 来完成，例如两个具体类型指针之间的转换、int 和指针之间的转换
4.dynamic_cast用于在类的继承层次之间进行类型转换，它既允许向上转型（Upcasting），也允许向下转型（Downcasting）。向上转型是无条件的，不会进行任何检测，所以都能成功；向下转型的前提必须是安全的，要借助 RTTI 进行检测，所有只有一部分能成功。
```

##### 20.右值引用和std：：move

```
右值虽然无法获取地址，但是右值引用是可以获取地址的，该地址表示临时对象的存储位置。
move 它并不是重新分配一块新的空间，将要拷贝的对象复制过来，而是"偷"了过来，将自己的指针指向别人的资源，然后将别人的指针修改为nullptr，这一步很重要，如果不将别人的指针修改为空，那么临时对象析构的时候就会释放掉这个资源，"偷"也白偷了。
```

##### 21.智能指针

```
智能指针是存储指向动态分配（堆）对象指针的类。除了能够在适当的时间自动删除指向的对象外，他们的工作机制很像C++的内置指针。智能指针在面对异常的时候格外有用，因为他们能够确保正确的销毁动态分配的对象。他们也可以用于跟踪被多用户共享的动态分配对象。
shared_poiter:当引用计数减少到0的时候就释放引用的对象。这种引用计数的增减发生在智能指针的构造函数，复制构造函数，赋值操作符，析构函数中。
这种方式使得多个智能指针同时对所引用的对象有拥有权，同时在引用计数减到0之后也会自动释放内存，也实现了auto_ptr和unique_ptr的资源释放的功能。
weak_poiter:弱引用，用来避免循环引用出现的情况，并手动释放内存。
```

##### 22.重载 重写 重定义

```
Overload(重载)：在C++程序中，可以将语义、功能相似的几个函数用同一个名字表示，但参数或返回值不同（包括类型、顺序不同），即函数重载。
（1）相同的范围（在同一个类中）；
（2）函数名字相同；
（3）参数不同；
（4）virtual 关键字可有可无。
Override(重写)：是指派生类函数覆盖基类函数，特征是：
（1）不同的范围（分别位于派生类与基类）；
（2）函数名字相同；
（3）参数相同；
（4）基类函数必须有virtual 关键字。
//实现多态的手段
Overwrite(重定义)：是指派生类的函数屏蔽了与其同名的基类函数，规则如下：
（1）如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual
关键字，基类的函数将被隐藏（注意别与重载混淆）。
（2）如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual
关键字。此时，基类的函数被隐藏（注意别与覆盖混淆）。
```

##### 23.**全局变量和局部变量有什么区别？实怎么实现的？操作系统和编译器是怎么知道的？**

```
全局变量是整个程序都可访问的变量，谁都可以访问，生存期在整个程序从运行到结束（在程序结束时所占内存释放）；
而局部变量存在于模块（子程序，函数）中，只有所在模块可以访问，其他模块不可直接访问，模块结束（函数调用完毕），局部变量消失，所占据的内存释放。
操作系统和编译器，可能是通过内存分配的位置来知道的，全局变量分配在全局数据段并且在程序开始运行的时候被加载.局部变量则分配在堆栈里面
```

##### 24.动态库和静态库

```
库是共享程序代码的方式，一般分为静态库和动态库。
静态库：链接时完整地拷贝至可执行文件中，被多次使用就有多份冗余拷贝。
动态库：链接时不复制，程序运行时由系统动态加载到内存，供程序调用，系统只加载一次，多个程序共用，节省内存。
```

##### 25lambda表达式的基本用法

```
Lambda表达式完整的声明格式如下：

[capture list] (params list) mutable exception-> return type { function body }
各项具体含义如下

capture list：捕获外部变量列表
params list：形参列表
mutable指示符：用来说用是否可以修改捕获的变量
exception：异常设定
return type：返回类型
function body：函数体
常用格式：[capture list] (params list) {function body}(assignment for params list)
[capture list] {function body}(...)
```

eg:

```
#include <iostream>
using namespace std;

int main()
{
    int a = 123;
    auto f = [a] { cout << a << endl; }; 
    f(); // 输出：123

    //或通过“函数体”后面的‘()’传入参数
    auto x = [](int a){cout << a << endl;}(123); 
}
```

[引用链接]: https://www.cnblogs.com/DswCnblog/p/5629165.html

##### 26.